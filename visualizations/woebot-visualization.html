<!DOCTYPE html>
<html lang="en">
<head>
    <title>Woebot - Therapeutic Emotional Processing</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f5f5f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        /* Landing page overlay */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
        }
        
        .grid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(#20B2AA 1px, transparent 1px),
                              linear-gradient(90deg, #20B2AA 1px, transparent 1px),
                              linear-gradient(rgba(230, 180, 34, 0.3) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(230, 180, 34, 0.3) 1px, transparent 1px);
            background-size: 20px 20px,
                             20px 20px,
                             5px 5px,
                             5px 5px;
            z-index: -1;
        }
        
        .content {
            max-width: 500px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            text-align: center;
        }
        
        .title {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #333;
            letter-spacing: 1px;
        }
        
        .description {
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 20px;
            color: #555;
        }
        
        .button {
            padding: 12px 24px;
            font-size: 16px;
            background: linear-gradient(135deg, #20B2AA, #E6B422);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            touch-action: manipulation;
            margin: 15px 0 5px 0;
            display: inline-block;
            text-decoration: none;
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        .gesture-container {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
        }
        
        .gesture-outline {
            width: 80px;
            height: 80px;
            border: 2px solid #20B2AA;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
            background: linear-gradient(135deg, rgba(32, 178, 170, 0.2), rgba(230, 180, 34, 0.2));
        }
        
        /* Woebot's gesture: open palm */
        .gesture-icon {
            width: 50px;
            height: 50px;
            position: relative;
        }
        
        .gesture-icon::before {
            content: "";
            position: absolute;
            width: 30px;
            height: 5px;
            background-color: #20B2AA;
            top: 22px;
            left: 10px;
            border-radius: 3px;
        }
        
        .gesture-icon::after {
            content: "";
            position: absolute;
            width: 30px;
            height: 30px;
            border: 5px solid #20B2AA;
            border-radius: 50%;
            top: 8px;
            left: 5px;
            opacity: 0.7;
        }
        
        /* Solid background element */
        #solid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(245, 248, 250);
            z-index: 1;
            display: block; /* Shown by default */
        }
        
        #visualization-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            font-family: 'Roboto Mono', monospace;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .sound-note {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background: linear-gradient(135deg, #20B2AA, #E6B422);
            padding: 10px 20px;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            z-index: 4;
            opacity: 1;
            transition: opacity 2s ease-in-out;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .sound-note.fade {
            opacity: 0;
        }
        
        /* Tutorial overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            z-index: 9000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            padding-bottom: 80px;
        }
        
        .tutorial-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .tutorial-hint {
            background: linear-gradient(135deg, #20B2AA, #E6B422);
            padding: 12px 20px;
            border-radius: 30px;
            max-width: 85%;
            text-align: center;
            margin-bottom: 0;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            animation: pulse 2s infinite;
         }

         @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
         }

         .tutorial-hint p {
            margin: 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
         }
        
        /* Touch indicator */
        .touch-indicator {
            position: fixed;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(32, 178, 170, 0.6), rgba(230, 180, 34, 0.6));
            pointer-events: none;
            z-index: 10;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Touch indicator element -->
    <div id="touch-indicator" class="touch-indicator"></div>
    
    <!-- Tutorial overlay -->
    <div id="tutorial-overlay" class="tutorial-overlay">
        <div id="tutorial-hint" class="tutorial-hint">
            <p id="tutorial-text">Tap anywhere to start</p>
        </div>
    </div>
    
    <!-- Landing page -->
    <div id="landing-overlay">
        <div class="grid-background"></div>
        
        <div class="content">
            <div class="gesture-container">
                <div class="gesture-outline">
                    <div class="gesture-icon"></div>
                </div>
            </div>
            
            <div class="title">Woebot: Therapeutic Processing</div>
            
            <div class="description">
                Experience how Woebot detects and responds to emotional patterns, transforming them through therapeutic frameworks rather than simulating emotions itself.
            </div>
            
            <div class="description">
                This visualization reveals Woebot's "soothe→solve" progression, where emotional states are recognized as patterns to be reshaped rather than states to be simulated.
            </div>
            
            <div class="description">
                <em>Tap, drag, or interact to experience how Woebot processes emotional patterns.</em>
            </div>
            
            <button id="start-button" class="button">BEGIN INTERACTION</button>
        </div>
    </div>
    
    <!-- Loading screen -->
    <div class="loading" id="loading">
        <div>
            <h2>Loading...</h2>
            <p>Preparing visualization</p>
        </div>
    </div>
    
    <!-- Sound note that fades away -->
    <div class="sound-note" id="sound-note">Sound available with headphones</div>
    
    <!-- Solid background (shown by default) -->
    <div id="solid-background"></div>
    
    <!-- p5.js visualization will be attached to this div -->
    <div id="visualization-overlay"></div>
    
    <script>
        // Global reference to p5 instance
        let p5Instance = null;
        
        // Tutorial state
        let tutorialStep = 0;
        let tutorialShown = false;
        const tutorialSteps = [
            "Tap and drag to reveal emotional patterns",
            "Double-tap to trigger a therapeutic response",
            "Hold to activate the soothe→solve progression"
        ];
        
        // Touch tracking for visualization
        let lastTouchPosition = {x: 0, y: 0, active: false, timer: 0};
        
        // Touch indicator element
        const touchIndicator = document.getElementById('touch-indicator');
        
        // Start the entire experience
        document.addEventListener('DOMContentLoaded', function() {
            // Set up the landing page button
            document.getElementById('start-button').addEventListener('click', startExperience);
            document.getElementById('start-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                startExperience();
            });
            
            // Set up tutorial handler
            document.getElementById('tutorial-hint').addEventListener('click', advanceTutorial);
            document.getElementById('tutorial-hint').addEventListener('touchend', function(e) {
                e.preventDefault();
                advanceTutorial();
            });
            
            // Disable default touch behaviors on the document
            document.addEventListener('touchmove', function(e) {
                if (!e.target.closest('button')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchstart', function(e) {
                if (!e.target.closest('button')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Initialize p5 sketch
            new p5(woebotSketch, 'visualization-overlay');
        });
        
        function startExperience() {
            // Hide landing page
            document.getElementById('landing-overlay').style.display = 'none';
            
            // Show main interface elements
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('visualization-overlay').style.display = 'block';
            document.getElementById('sound-note').style.display = 'block';
            
            // Hide loading screen after a delay
            setTimeout(function() {
                document.getElementById('loading').style.display = 'none';
            }, 1500);
            
            // Fade out sound note after 5 seconds
            setTimeout(function() {
                document.getElementById('sound-note').classList.add('fade');
            }, 5000);
            
            // Show tutorial after a short delay
            setTimeout(function() {
                if (!tutorialShown) {
                    showTutorial();
                }
            }, 2000);
        }
        
        function showTutorial() {
            tutorialStep = 0;
            document.getElementById('tutorial-text').textContent = tutorialSteps[tutorialStep];
            document.getElementById('tutorial-overlay').classList.add('active');
            tutorialShown = true;
        }
        
        function advanceTutorial() {
            tutorialStep++;
            if (tutorialStep < tutorialSteps.length) {
                document.getElementById('tutorial-text').textContent = tutorialSteps[tutorialStep];
            } else {
                document.getElementById('tutorial-overlay').classList.remove('active');
            }
        }
        
        // Show touch indicator at the specified position
        function showTouchIndicator(x, y) {
            touchIndicator.style.left = x + 'px';
            touchIndicator.style.top = y + 'px';
            touchIndicator.style.opacity = '1';
            
            // Hide indicator after a short delay
            setTimeout(() => {
                touchIndicator.style.opacity = '0';
            }, 300);
        }
        
        // Woebot visualization sketch
        const woebotSketch = function(p) {
            // Store reference to p5 instance
            p5Instance = p;
            
            // Emotion patterns data structure
            let patterns = [];
            const MAX_PATTERNS = 30;
            
            // Therapeutic response system
            let therapeuticResponses = [];
            const MAX_RESPONSES = 10;
            
            // Central palm - representing Woebot's gesture
            let palm;
            
            // Audio elements
            let calmSound;
            let therapeuticSound;
            let tealAmberSound;
            
            // Interaction tracking
            let isTherapeuticMode = false;
            let therapeuticTimer = 0;
            let longPressTimer = 0;
            let isLongPressing = false;
            let longPressX = 0;
            let longPressY = 0;
            
            // Color palette based on Woebot's teal→amber gradient
            const colors = {
                teal: [32, 178, 170],
                amber: [230, 180, 34],
                error: [220, 60, 50],
                neutral: [180, 180, 180]
            };
            
            // Emotional pattern types
            const patternTypes = [
                { name: "catastrophizing", color: colors.error, spiral: true, rigidity: 0.8 },
                { name: "rumination", color: colors.error, spiral: true, rigidity: 0.5 },
                { name: "mind-reading", color: colors.error, spiral: false, rigidity: 0.7 },
                { name: "should-statements", color: colors.error, spiral: false, rigidity: 0.9 },
                { name: "labeling", color: colors.error, spiral: false, rigidity: 0.6 },
                { name: "hopelessness", color: colors.error, spiral: true, rigidity: 0.7 },
                { name: "dissociation", color: colors.neutral, spiral: false, rigidity: 0.2 },
                { name: "neutral", color: colors.neutral, spiral: false, rigidity: 0.4 }
            ];
            
            // Therapeutic response types
            const responseTypes = [
                { name: "grounding", color: colors.teal, duration: 180 },
                { name: "reframe", color: colors.teal, duration: 120 },
                { name: "validation", color: colors.teal, duration: 90 },
                { name: "activation", color: colors.amber, duration: 150 },
                { name: "problem-solving", color: colors.amber, duration: 160 },
                { name: "mindfulness", color: colors.teal, duration: 100 }
            ];
            
            p.preload = function() {
                // Load sounds
                try {
                    p.soundFormats('mp3', 'wav');
                    calmSound = p.loadSound('woebot-calm.mp3');
                    therapeuticSound = p.loadSound('woebot-therapeutic.mp3');
                    tealAmberSound = p.loadSound('woebot-teal-amber.mp3');
                } catch(e) {
                    console.error("Error loading sounds:", e);
                    // Create silent replacements
                    calmSound = {
                        play: function() { console.log("Would play calm sound"); },
                        setVolume: function() {}
                        stop: function() {}  // Added this method
                    };
                    therapeuticSound = {
                        play: function() { console.log("Would play therapeutic sound"); },
                        setVolume: function() {}
                        stop: function() {}  // Added this method
                    };
                    tealAmberSound = {
                        play: function() { console.log("Would play teal-amber sound"); },
                        setVolume: function() {}
                        stop: function() {}  // Added this method
                    };
                }
            };
            
            p.setup = function() {
                // Create canvas
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('visualization-overlay');
                
                // Initialize central palm
                palm = {
                    x: p.width / 2,
                    y: p.height / 2,
                    size: 100,
                    rotation: 0,
                    pulseSize: 0,
                    pulseDir: 1,
                    color: colors.teal.concat([255])
                };
                
                // Create initial patterns
                for (let i = 0; i < 15; i++) {
                    createPattern(
                        p.random(p.width), 
                        p.random(p.height),
                        p.random(patternTypes)
                    );
                }
                
                // Initialize audio context
                p.userStartAudio();
            };
            
            function createPattern(x, y, type) {
                if (!type) {
                    type = p.random(patternTypes);
                }
                
                const pattern = {
                    x: x,
                    y: y,
                    vx: p.random(-1, 1),
                    vy: p.random(-1, 1),
                    size: p.random(20, 60),
                    type: type,
                    opacity: 0,
                    fadeSpeed: p.random(0.01, 0.03),
                    age: 0,
                    lifespan: p.random(300, 600),
                    rotation: p.random(p.TWO_PI),
                    rotationSpeed: p.random(-0.02, 0.02) * type.rigidity,
                    vertices: Math.floor(p.random(3, 7)),
                    distortion: type.rigidity * 0.5,
                    spiral: type.spiral,
                    spiralTightness: p.random(0.1, 0.3),
                    spiralRotation: p.random(p.TWO_PI),
                    beingProcessed: false,
                    processingProgress: 0,
                    originalColor: type.color.slice(),
                    currentColor: type.color.slice(),
                    targetColor: type.color.slice()
                };
                
                patterns.push(pattern);
                
                // Remove oldest if we exceed max
                if (patterns.length > MAX_PATTERNS) {
                    patterns.shift();
                }
                
                return pattern;
            }
            
            function createTherapeuticResponse(x, y, targetPattern) {
                const type = p.random(responseTypes);
                
                const response = {
                    x: x,
                    y: y,
                    targetPattern: targetPattern,
                    type: type,
                    size: 50,
                    opacity: 0,
                    fadeSpeed: 0.05,
                    age: 0,
                    lifespan: type.duration,
                    color: type.color.concat([0]), // Start with 0 alpha
                    expandWave: 0,
                    expandSpeed: 2,
                    expandOpacity: 1,
                    text: type.name,
                    pulseAmount: 0,
                    pulseDir: 1
                };
                
                therapeuticResponses.push(response);
                
                // Remove oldest if we exceed max
                if (therapeuticResponses.length > MAX_RESPONSES) {
                    therapeuticResponses.shift();
                }
                
                return response;
            }
            
            function updatePattern(pattern) {
                // Age the pattern
                pattern.age++;
                
                // Handle fade in/out
                if (pattern.age < 60) {
                    pattern.opacity += pattern.fadeSpeed;
                    if (pattern.opacity > 1) pattern.opacity = 1;
                } else if (pattern.age > pattern.lifespan - 60) {
                    pattern.opacity -= pattern.fadeSpeed;
                    if (pattern.opacity < 0) pattern.opacity = 0;
                }
                
                // Update rotation
                pattern.rotation += pattern.rotationSpeed;
                
                // Update position with slight random movement
                if (!pattern.beingProcessed) {
                    pattern.x += pattern.vx + p.random(-0.5, 0.5) * pattern.type.rigidity;
                    pattern.y += pattern.vy + p.random(-0.5, 0.5) * pattern.type.rigidity;
                    
                    // Bounce off edges
                    if (pattern.x < 0 || pattern.x > p.width) pattern.vx *= -1;
                    if (pattern.y < 0 || pattern.y > p.height) pattern.vy *= -1;
                } else {
                    // If being processed, update color towards target (teal or amber)
                    for (let i = 0; i < 3; i++) {
                        pattern.currentColor[i] = p.lerp(
                            pattern.currentColor[i], 
                            pattern.targetColor[i], 
                            0.05
                        );
                    }
                    
                    // Update processing progress
                    pattern.processingProgress += 0.01;
                    if (pattern.processingProgress >= 1) {
                        // Finished processing
                        pattern.beingProcessed = false;
                        pattern.lifespan = pattern.age + 60; // Set to fade out soon
                    }
                }
            }
            
            function drawPattern(pattern) {
                p.push();
                p.translate(pattern.x, pattern.y);
                p.rotate(pattern.rotation);
                
                // Set color with opacity
                const patternColor = p.color(
                    pattern.currentColor[0], 
                    pattern.currentColor[1], 
                    pattern.currentColor[2], 
                    255 * pattern.opacity
                );
                p.fill(patternColor);
                
                // Draw different shapes based on pattern type
                if (pattern.spiral) {
                    // Draw spiral pattern (for rumination, catastrophizing)
                    p.noStroke();
                    p.beginShape();
                    
                    for (let i = 0; i < 200; i++) {
                        const angle = pattern.spiralRotation + i * 0.1;
                        const radius = i * pattern.spiralTightness;
                        
                        if (radius > pattern.size) break;
                        
                        const x = p.cos(angle) * radius;
                        const y = p.sin(angle) * radius;
                        
                        p.vertex(x, y);
                    }
                    
                    p.endShape();
                } else {
                    // Draw angular shape (for other pattern types)
                    p.beginShape();
                    
                    for (let i = 0; i < pattern.vertices; i++) {
                        const angle = p.map(i, 0, pattern.vertices, 0, p.TWO_PI);
                        
                        // Add distortion based on rigidity
                        const distortionAmount = pattern.distortion * p.sin(angle * 3 + p.frameCount * 0.05);
                        const radius = pattern.size * (1 + distortionAmount * 0.2);
                        
                        const x = p.cos(angle) * radius;
                        const y = p.sin(angle) * radius;
                        
                        p.vertex(x, y);
                    }
                    
                    p.endShape(p.CLOSE);
                }
                
                // If pattern is being processed, show progress
                if (pattern.beingProcessed) {
                    // Draw processing indicator
                    p.noFill();
                    p.stroke(255, 255, 255, 100 * pattern.opacity);
                    p.strokeWeight(3);
                    p.arc(0, 0, pattern.size * 1.5, pattern.size * 1.5, 
                         -p.HALF_PI, -p.HALF_PI + p.TWO_PI * pattern.processingProgress);
                }
                
                p.pop();
            }
            
            function updateTherapeuticResponse(response) {
                // Age the response
                response.age++;
                
                // Handle fade in/out
                if (response.age < 30) {
                    response.opacity += response.fadeSpeed;
                    if (response.opacity > 1) response.opacity = 1;
                    response.color[3] = 255 * response.opacity;
                } else if (response.age > response.lifespan - 30) {
                    response.opacity -= response.fadeSpeed;
                    if (response.opacity < 0) response.opacity = 0;
                    response.color[3] = 255 * response.opacity;
                }
                
                // Update expanding wave
                response.expandWave += response.expandSpeed;
                response.expandOpacity = p.map(response.expandWave, 0, 200, 1, 0, true);
                
                // Update pulse effect
                response.pulseAmount += 0.1 * response.pulseDir;
                if (Math.abs(response.pulseAmount) > 5) {
                    response.pulseDir *= -1;
                }
                
                // Move toward target pattern if one exists
                if (response.targetPattern && response.opacity > 0.5) {
                    // Move toward target
                    response.x = p.lerp(response.x, response.targetPattern.x, 0.05);
                    response.y = p.lerp(response.y, response.targetPattern.y, 0.05);
                    
                    // If close enough, start processing the pattern
                    const dist = p.dist(response.x, response.y, response.targetPattern.x, response.targetPattern.y);
                    if (dist < 30 && !response.targetPattern.beingProcessed) {
                        startProcessingPattern(response.targetPattern, response.type.color);
                    }
                }
            }
            
            function startProcessingPattern(pattern, therapeuticColor) {
                // Start the transformation process
                pattern.beingProcessed = true;
                pattern.processingProgress = 0;
                pattern.targetColor = therapeuticColor;
                
                // Slow down and stabilize the pattern
                pattern.vx *= 0.2;
                pattern.vy *= 0.2;
                pattern.rotationSpeed *= 0.3;
            }
            
            function drawTherapeuticResponse(response) {
                p.push();
                p.translate(response.x, response.y);
                
                // Draw expanding circle
                if (response.expandWave < 200) {
                    p.noFill();
                    p.stroke(response.color[0], response.color[1], response.color[2], 255 * response.expandOpacity);
                    p.strokeWeight(2);
                    p.ellipse(0, 0, response.expandWave, response.expandWave);
                }
                
                // Draw main circle with pulsing effect
                p.fill(response.color[0], response.color[1], response.color[2], response.color[3]);
                p.noStroke();
                p.ellipse(0, 0, response.size + response.pulseAmount, response.size + response.pulseAmount);
                
                // Draw text label
                p.fill(255, 255, 255, response.color[3]);
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(12);
                p.text(response.type.name, 0, 0);
                
                p.pop();
            }
            
            function updatePalm() {
                // Update pulse effect
                palm.pulseSize += 0.2 * palm.pulseDir;
                if (Math.abs(palm.pulseSize) > 5) {
                    palm.pulseDir *= -1;
                }
                
                // In therapeutic mode, make pulse more pronounced
                if (isTherapeuticMode) {
                    palm.pulseSize = p.sin(p.frameCount * 0.1) * 10;
                    
                    // Transition color toward amber
                    palm.color[0] = p.lerp(palm.color[0], colors.amber[0], 0.05);
                    palm.color[1] = p.lerp(palm.color[1], colors.amber[1], 0.05);
                    palm.color[2] = p.lerp(palm.color[2], colors.amber[2], 0.05);
                } else {
                    // Transition color back toward teal
                    palm.color[0] = p.lerp(palm.color[0], colors.teal[0], 0.05);
                    palm.color[1] = p.lerp(palm.color[1], colors.teal[1], 0.05);
                    palm.color[2] = p.lerp(palm.color[2], colors.teal[2], 0.05);
                }
            }
            
            function drawPalm() {
                p.push();
                p.translate(palm.x, palm.y);
                
                // Draw glow
                p.fill(palm.color[0], palm.color[1], palm.color[2], 50);
                p.noStroke();
                p.ellipse(0, 0, palm.size * 1.5 + palm.pulseSize, palm.size * 1.5 + palm.pulseSize);
                
                // Draw palm outline
                p.noFill();
                p.stroke(palm.color[0], palm.color[1], palm.color[2], 200);
                p.strokeWeight(3);
                p.ellipse(0, 0, palm.size + palm.pulseSize, palm.size + palm.pulseSize);
                
                // Draw palm lines (symbolizing an open palm)
                p.stroke(palm.color[0], palm.color[1], palm.color[2], 150);
                p.strokeWeight(2);
                
                // Life line (curved)
                p.beginShape();
                p.noFill();
                p.curveVertex(-30, -20);
                p.curveVertex(-20, 0);
                p.curveVertex(-10, 20);
                p.curveVertex(0, 30);
                p.endShape();
                
                // Heart line (straight)
                p.line(-30, -10, 30, -10);
                
                // Head line (medium)
                p.line(-20, 10, 20, 10);
                
                // Fate line (vertical)
                p.line(0, -30, 0, 30);
                
                p.pop();
                
                // In therapeutic mode, draw soothe→solve gradient rays
                if (isTherapeuticMode) {
                    p.push();
                    p.translate(palm.x, palm.y);
                    
                    // Draw gradient rays
                    for (let i = 0; i < 12; i++) {
                        const angle = i * (p.TWO_PI / 12) + p.frameCount * 0.01;
                        const rayLength = 150 + p.sin(p.frameCount * 0.05 + i) * 20;
                        
                        p.push();
                        p.rotate(angle);
                        
                        // Create gradient from teal to amber
                        for (let j = 0; j < rayLength; j += 3) {
                            const t = j / rayLength;
                            const rayColor = p.lerpColor(
                                p.color(colors.teal[0], colors.teal[1], colors.teal[2], 100 * (1 - t)),
                                p.color(colors.amber[0], colors.amber[1], colors.amber[2], 100 * (1 - t)),
                                t
                            );
                            
                            p.stroke(rayColor);
                            p.strokeWeight(2 * (1 - t));
                            p.point(j, 0);
                        }
                        
                        p.pop();
                    }
                    
                    p.pop();
                }
            }
            
            function triggerTherapeuticMode() {
                isTherapeuticMode = true;
                therapeuticTimer = 0;
                
                // Play sound
                therapeuticSound.setVolume(0.3);
                therapeuticSound.play();
            }
            
            function endTherapeuticMode() {
                isTherapeuticMode = false;
                
                // Play sound transition
                tealAmberSound.setVolume(0.2);
                tealAmberSound.play();
            }
            
            function processNearbyPatterns(x, y, radius) {
                let processed = false;
                
                // Find patterns within radius
                for (let i = 0; i < patterns.length; i++) {
                    const dist = p.dist(x, y, patterns[i].x, patterns[i].y);
                    
                    if (dist < radius && !patterns[i].beingProcessed) {
                        // Create therapeutic response
                        createTherapeuticResponse(x, y, patterns[i]);
                        processed = true;
                    }
                }
                
                return processed;
            }
            
            function drawLongPressIndicator() {
                if (isLongPressing) {
                    p.push();
                    p.noFill();
                    p.stroke(colors.teal[0], colors.teal[1], colors.teal[2], 150);
                    p.strokeWeight(2);
                    
                    // Draw progress circle
                    const progress = p.map(longPressTimer, 0, 30, 0, p.TWO_PI);
                    p.arc(longPressX, longPressY, 60, 60, -p.HALF_PI, -p.HALF_PI + progress);
                    
                    p.pop();
                }
            }
            
            p.draw = function() {
                // Clear canvas
                p.clear();
                
                // Update therapeutic mode timer
                if (isTherapeuticMode) {
                    therapeuticTimer++;
                    if (therapeuticTimer > 180) { // 3 seconds
                        endTherapeuticMode();
                    }
                }
                
                // Update and draw patterns
                for (let i = patterns.length - 1; i >= 0; i--) {
                    updatePattern(patterns[i]);
                    drawPattern(patterns[i]);
                    
                    // Remove expired patterns
                    if (patterns[i].opacity <= 0 && patterns[i].age > 60) {
                        patterns.splice(i, 1);
                    }
                }
                
                // Update and draw therapeutic responses
                for (let i = therapeuticResponses.length - 1; i >= 0; i--) {
                    updateTherapeuticResponse(therapeuticResponses[i]);
                    drawTherapeuticResponse(therapeuticResponses[i]);
                    
                    // Remove expired responses
                    if (therapeuticResponses[i].age > therapeuticResponses[i].lifespan) {
                        therapeuticResponses.splice(i, 1);
                    }
                }
                
                // Update and draw palm
                updatePalm();
                drawPalm();
                
                // Draw long press indicator
                drawLongPressIndicator();
                
                // Occasionally create new patterns
                if (p.frameCount % 90 === 0 && patterns.length < MAX_PATTERNS) {
                    createPattern(
                        p.random(p.width), 
                        p.random(p.height),
                        p.random(patternTypes)
                    );
                }
                
                // Update long press timer
                if (isLongPressing) {
                    longPressTimer++;
                    if (longPressTimer >= 30) { // Half a second
                        // Trigger soothe→solve progression
                        triggerTherapeuticMode();
                        
                        // Process all patterns within a large radius
                        processNearbyPatterns(longPressX, longPressY, 200);
                        
                        // Reset long press
                        isLongPressing = false;
                        longPressTimer = 0;
                    }
                }
            };
            
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                
                // Center palm
                palm.x = p.width / 2;
                palm.y = p.height / 2;
            };
            
            p.mousePressed = function() {
                // Start long press
                isLongPressing = true;
                longPressTimer = 0;
                longPressX = p.mouseX;
                longPressY = p.mouseY;
                
                // Ensure audio is initialized
                p.userStartAudio();
                
                return false;
            };
            
            p.mouseReleased = function() {
                // If it was a short press
                if (isLongPressing && longPressTimer < 30) {
                    // Create a new pattern at mouse position
                    createPattern(p.mouseX, p.mouseY);
                    
                    // Play calm sound
                    calmSound.setVolume(0.2);
                    calmSound.play();
                }
                
                // Reset long press
                isLongPressing = false;
                longPressTimer = 0;
                
                return false;
            };
            
            p.mouseDragged = function() {
                // Reset long press when dragging
                isLongPressing = false;
                
                // Create small pattern while dragging
                if (p.frameCount % 10 === 0) {
                    const pattern = createPattern(p.mouseX, p.mouseY);
                    pattern.size *= 0.7; // Smaller pattern when dragging
                }
                
                return false;
            };
            
            p.doubleClicked = function() {
                // Create therapeutic response
                processNearbyPatterns(p.mouseX, p.mouseY, 100);
                
                // Play therapeutic sound
                therapeuticSound.setVolume(0.2);
                therapeuticSound.play();
                
                return false;
            };
            
            // Touch event handlers
            p.touchStarted = function() {
                if (p.touches.length > 0) {
                    const touchX = p.touches[0].x;
                    const touchY = p.touches[0].y;
                    
                    // Start long press
                    isLongPressing = true;
                    longPressTimer = 0;
                    longPressX = touchX;
                    longPressY = touchY;
                    
                    // Show touch indicator
                    showTouchIndicator(touchX, touchY);
                    
                    // Ensure audio is initialized
                    p.userStartAudio();
                }
                
                return false;
            };
            
            p.touchEnded = function() {
                // If it was a short press
                if (isLongPressing && longPressTimer < 30) {
                    if (p.touches.length > 0) {
                        const touchX = p.touches[0].x;
                        const touchY = p.touches[0].y;
                        
                        // Create a new pattern at touch position
                        createPattern(touchX, touchY);
                        
                        // Play calm sound
                        calmSound.setVolume(0.2);
                        calmSound.play();
                    }
                }
                
                // Reset long press
                isLongPressing = false;
                longPressTimer = 0;
                
                return false;
            };
            
            p.touchMoved = function() {
                // Reset long press when dragging
                isLongPressing = false;
                
                if (p.touches.length > 0) {
                    const touchX = p.touches[0].x;
                    const touchY = p.touches[0].y;
                    
                    // Create small pattern while dragging
                    if (p.frameCount % 10 === 0) {
                        const pattern = createPattern(touchX, touchY);
                        pattern.size *= 0.7; // Smaller pattern when dragging
                    }
                    
                    // Show touch indicator
                    showTouchIndicator(touchX, touchY);
                }
                
                return false;
            };
        };
    </script>
</body>
</html>
